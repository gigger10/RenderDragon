name: Patch Minecraft with mtbinloader2

on:
  workflow_dispatch:
    inputs:
      mcversion_path:
        description: "Path to mcversion.txt"
        default: "mcversion.txt"
        required: true
        type: string
      package_name:
        description: "Optional package name override (e.g., com.example.mcpatched)"
        required: false
        type: string
      # Keystore can also be provided via repository or org secrets (recommended).
      keystore_base64:
        description: "BASE64 of your .jks/.keystore (leave blank to auto-generate debug keystore)"
        required: false
        type: string
      keystore_alias:
        description: "Keystore alias (ignored if auto-generating)"
        required: false
        type: string
      keystore_storepass:
        description: "Keystore store password (ignored if auto-generating)"
        required: false
        type: string
      keystore_keypass:
        description: "Key password (ignored if auto-generating)"
        required: false
        type: string

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      url32: ${{ steps.parse.outputs.url32 }}
      url64: ${{ steps.parse.outputs.url64 }}
      do32: ${{ steps.parse.outputs.do32 }}
      do64: ${{ steps.parse.outputs.do64 }}
      package_name: ${{ steps.pkgn.outputs.package_name }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Parse mcversion.txt
        id: parse
        shell: bash
        run: |
          set -euo pipefail
          FILE="${{ inputs.mcversion_path }}"
          if [[ ! -f "$FILE" ]]; then
            echo "mcversion.txt not found at: $FILE" >&2
            exit 1
          fi
          url32=""
          url64=""
          while IFS= read -r line; do
            # Trim spaces
            line="$(echo "$line" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')"
            [[ -z "$line" ]] && continue
            # Accept "32: link" or "64: link" (case-insensitive)
            if echo "$line" | grep -qiE '^32[[:space:]]*:'; then
              url32="$(echo "$line" | cut -d: -f2- | xargs)"
            elif echo "$line" | grep -qiE '^64[[:space:]]*:'; then
              url64="$(echo "$line" | cut -d: -f2- | xargs)"
            fi
          done < "$FILE"

          [[ -n "$url32" ]] && echo "Found 32-bit URL: $url32" || echo "No 32-bit URL provided."
          [[ -n "$url64" ]] && echo "Found 64-bit URL: $url64" || echo "No 64-bit URL provided."

          echo "url32=$url32" >> "$GITHUB_OUTPUT"
          echo "url64=$url64" >> "$GITHUB_OUTPUT"
          echo "do32=$([[ -n "$url32" ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"
          echo "do64=$([[ -n "$url64" ]] && echo true || echo false)" >> "$GITHUB_OUTPUT"

      - name: Normalize package name input
        id: pkgn
        run: |
          # Pass through or empty
          echo "package_name=${{ inputs.package_name }}" >> "$GITHUB_OUTPUT"

  patch:
    needs: prepare
    if: ${{ needs.prepare.outputs.do32 == 'true' || needs.prepare.outputs.do64 == 'true' }}
    runs-on: ubuntu-latest

    strategy:
      fail-fast: false
      matrix:
        include:
          - archlabel: "32"
            abi: "armeabi-v7a"
            addneeded: "libmaterialbinloader-arm.so"
            mtb_asset: "libmaterialbinloader-arm.so"
            url: ${{ needs.prepare.outputs.url32 }}
            do: ${{ needs.prepare.outputs.do32 }}
          - archlabel: "64"
            abi: "arm64-v8a"
            addneeded: "libmaterialbinloader-arm64.so"
            mtb_asset: "libmaterialbinloader-arm64.so"
            url: ${{ needs.prepare.outputs.url64 }}
            do: ${{ needs.prepare.outputs.do64 }}

    steps:
      - name: Skip if this arch not requested
        if: ${{ matrix.do != 'true' }}
        run: echo "Skipping ${{ matrix.archlabel }}-bit (no URL)."

      - name: Checkout
        if: ${{ matrix.do == 'true' }}
        uses: actions/checkout@v4

      - name: Set up Java (for apktool & signing)
        if: ${{ matrix.do == 'true' }}
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"

      - name: Install tools
        if: ${{ matrix.do == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          sudo apt-get update
          sudo apt-get install -y unzip zip curl xxd

          # Download patchelf (static build for Linux x86_64)
          PATCHELF_URL="https://github.com/NixOS/patchelf/releases/download/0.18.0/patchelf-0.18.0-x86_64.tar.bz2"
          curl -L "$PATCHELF_URL" -o patchelf.tar.bz2
          tar -xjf patchelf.tar.bz2
          # Put patchelf in PATH
          sudo mv patchelf-*/bin/patchelf /usr/local/bin/patchelf
          patchelf --version

          # Download mtbinloader2 .so (v0.1.9-beta)
          mkdir -p mtb
          curl -L "https://github.com/mcbegamerxx954/mtbinloader2/releases/download/v0.1.9-beta/${{ matrix.mtb_asset }}" -o "mtb/${{ matrix.mtb_asset }}"

          # Uber APK Signer (includes zipalign)
          curl -L "https://github.com/patrickfav/uber-apk-signer/releases/download/v1.3.0/uber-apk-signer-1.3.0.jar" -o uber.jar

          # apktool (download jar directly)
          curl -L "https://github.com/iBotPeaches/Apktool/releases/download/v2.9.3/apktool_2.9.3.jar" -o apktool.jar

      - name: Prepare keystore
        if: ${{ matrix.do == 'true' }}
        id: keystore
        shell: bash
        env:
          INP_BASE64: ${{ inputs.keystore_base64 }}
          INP_ALIAS: ${{ inputs.keystore_alias }}
          INP_STOREPASS: ${{ inputs.keystore_storepass }}
          INP_KEYPASS: ${{ inputs.keystore_keypass }}
        run: |
          set -euo pipefail
          mkdir -p keystore
          if [[ -n "${INP_BASE64}" ]]; then
            echo "$INP_BASE64" | base64 -d > keystore/keystore.jks
            echo "Using provided keystore."
            echo "alias=${INP_ALIAS}" >> "$GITHUB_OUTPUT"
            echo "storepass=${INP_STOREPASS}" >> "$GITHUB_OUTPUT"
            echo "keypass=${INP_KEYPASS}" >> "$GITHUB_OUTPUT"
            echo "path=keystore/keystore.jks" >> "$GITHUB_OUTPUT"
          else
            echo "No keystore provided. Generating a debug keystoreâ€¦"
            keytool -genkeypair -v -keystore keystore/debug.jks -storepass android -keypass android -alias androiddebugkey \
              -keyalg RSA -keysize 2048 -validity 10000 -dname "CN=Android Debug,O=Android,C=US"
            echo "alias=androiddebugkey" >> "$GITHUB_OUTPUT"
            echo "storepass=android" >> "$GITHUB_OUTPUT"
            echo "keypass=android" >> "$GITHUB_OUTPUT"
            echo "path=keystore/debug.jks" >> "$GITHUB_OUTPUT"
          fi

      - name: Download APK (${{ matrix.archlabel }}-bit)
        if: ${{ matrix.do == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p work/${{ matrix.archlabel }}
          cd work/${{ matrix.archlabel }}
          echo "Downloading ${{ matrix.url }}"
          curl -L "${{ matrix.url }}" -o input.apk

      - name: Unpack APK
        if: ${{ matrix.do == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          cd work/${{ matrix.archlabel }}
          mkdir -p apk
          unzip -q input.apk -d apk

          if [[ ! -f "apk/lib/${{ matrix.abi }}/libminecraftpe.so" ]]; then
            echo "libminecraftpe.so not found in lib/${{ matrix.abi }} of APK." >&2
            echo "Ensure the provided APK is a full APK for the specified ABI (${{ matrix.abi }}), not a split base." >&2
            exit 1
          fi

          cp "apk/lib/${{ matrix.abi }}/libminecraftpe.so" libminecraftpe.so

      - name: Patch libminecraftpe.so with patchelf
        if: ${{ matrix.do == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          cd work/${{ matrix.archlabel }}
          # Add dependency to material bin loader
          patchelf --add-needed "${{ matrix.addneeded }}" libminecraftpe.so
          # replace back into APK tree
          install -m 0644 libminecraftpe.so "apk/lib/${{ matrix.abi }}/libminecraftpe.so"
          # Add the loader .so into the APK tree (name must match NEEDED)
          install -m 0644 "../../mtb/${{ matrix.mtb_asset }}" "apk/lib/${{ matrix.abi }}/${{ matrix.mtb_asset }}"

      - name: Rebuild unsigned APK (zip)
        if: ${{ matrix.do == 'true' }}
        shell: bash
        run: |
          set -euo pipefail
          cd work/${{ matrix.archlabel }}/apk
          # Repack preserving directory structure
          zip -qr ../unsigned.apk .

      - name: Optionally rename package (applicationId) with apktool
        if: ${{ matrix.do == 'true' && needs.prepare.outputs.package_name != '' }}
        shell: bash
        env:
          PKG: ${{ needs.prepare.outputs.package_name }}
        run: |
          set -euo pipefail
          cd work/${{ matrix.archlabel }}
          rm -rf decoded
          # Decode
          java -jar ../../apktool.jar d unsigned.apk -o decoded -f
          # Rebuild with renamed manifest package
          java -jar ../../apktool.jar b decoded --use-aapt2 --rename-manifest-package "$PKG" -o rebuilt.apk
          mv rebuilt.apk unsigned.apk

      - name: Sign (zipalign + sign) with Uber APK Signer
        if: ${{ matrix.do == 'true' }}
        shell: bash
        env:
          KS_PATH: ${{ steps.keystore.outputs.path }}
          KS_ALIAS: ${{ steps.keystore.outputs.alias }}
          KS_STOREPASS: ${{ steps.keystore.outputs.storepass }}
          KS_KEYPASS: ${{ steps.keystore.outputs.keypass }}
        run: |
          set -euo pipefail
          cd work/${{ matrix.archlabel }}
          # Uber APK Signer will zipalign and sign; we pass explicit keystore
          java -jar ../../uber.jar \
            --ks "$KS_PATH" --ksAlias "$KS_ALIAS" \
            --ksPass "$KS_STOREPASS" --keyPass "$KS_KEYPASS" \
            --in unsigned.apk --out .
          # Output gets name like unsigned-aligned-debugSigned.apk or similar
          # Normalize the name:
          OUT="minecraft-patched-${{ matrix.archlabel }}.apk"
          # Find the signed apk
          SIGNED="$(ls -1 *Signed.apk | head -n1)"
          if [[ -z "$SIGNED" ]]; then
            echo "Signed APK not found." >&2
            ls -la
            exit 1
          fi
          mv "$SIGNED" "$OUT"
          echo "OUT=$OUT" >> "$GITHUB_OUTPUT"

      - name: Upload artifact (${{ matrix.archlabel }}-bit)
        if: ${{ matrix.do == 'true' }}
        uses: actions/upload-artifact@v4
        with:
          name: minecraft-patched-${{ matrix.archlabel }}
          path: work/${{ matrix.archlabel }}/minecraft-patched-${{ matrix.archlabel }}.apk
          if-no-files-found: error
